# 第3章 アジャイルとプロセス

2001年、著名な開発者、著者、コンサルタントらのグループが「<span class="index">アジャイルソフトウェア開発宣言</span>（Manifesto for Agile Software Development）」[Bec01]にサインした。以下のような内容である。

> - プロセスやツールよりも個人と対話を
> - 包括的なドキュメントよりも動くソフトウェアを
> - 契約交渉よりも顧客との協調を
> - 計画に従うことよりも変化への対応を

> 左記のことがらに価値があることを認めながらも、私たちは右記のことがらにより価値をおく。

★Agile methodの調整、6版のアジャイルソフトウェア開発手法じゃなかった感…全体を見て調整
★あわせて、アジャイルXXが突如出てくるのでナヤマシイ。。

このようなアジャイル開発[訳注1]の基礎をなす考え方は、アジャイル手法[1]へと繋がった。アジャイル手法は従来のソフトウェアエンジニアリングで実際に直面する弱点を克服するために開発された。アジャイル開発は、大きな利益をもたらす可能性がある。しかし、あらゆるプロジェクト、プロダクト、人々、状況において利用できるとは限らない。また、アジャイルは厳格なソフトウェアエンジニアリングのプラクティスを否定するものでもなければ、ソフトウェアに関する作業の概念を覆すものでもない。

[訳注1] アジャイル（Agile）という単語は「俊敏な、敏捷な」という意味だが、ソフトウェアエンジニアリングの文脈では手法や体系の意味も持つ。アジャイル開発は俊敏な開発を指すが、アジャイル体系における開発手法という意味にもなる。アジャイルという単語は多数登場するので慣れよう。

[1] アジャイル手法は、軽量な、もしくは無駄のない（lean）方法論と呼ばれることがある。

近年の経済環境においては、時間の経過とともにコンピュータシステム（例：モバイルアプリケーション）がどのように発展していくかを、前もって予測することは困難、もしくは不可能である。市場の状況は急速に変化し、顧客はシステムの改善を要求し、新しい競合が警告もなく登場し脅威となる。ほとんどの場合、プロジェクトが開始される前に、完全に要求を定義することはもはや不可能である。ソフトウェアエンジニアは流動するビジネス環境に対応できるよう俊敏（Agile）でなければならない。

流動性は変化を意味する。この変化が制御できない、もしくは貧弱な管理状況では、変化は高価となる。ソフトウェアプロセスを通じて変更のコストを減らす仕組みが、アジャイルアプローチの最も魅力的な特徴のひとつである。

Alistair Cockburnは、アジャイルソフトウェア開発の示唆に富む著書[Coc02]において、第2章にて紹介した規範的なプロセスモデルは重大な欠点があり、「ソフトウェアを構築する人間の弱さを忘れている」と述べている。

ソフトウェアエンジニアはロボットではない。ソフトウェアエンジニアの働くスタイルはさまざまであり、スキルレベル、創造性、規律、堅実さ、自発性はそれぞれ異なる。とあるエンジニアは記述された資料でうまくコミュニケーションをとるが、同じことができない人もいる。仮に現場で使われるプロセスモデルが存在するならば、それモデルは規律を守るための現実的な仕組みを持つか、ソフトウェアエンジニアリングに従事する人への「寛容さ」を示さねばならない。


## 3.1 アジャイルとは何か

ソフトウェアエンジニアリングの文脈で「アジャイル」とは何を意味するのか。Ivar Jacobsonは「変化が当たり前となったことがアジャイルの推進力となった」[Jac02a]と述べている。Jacobsonが記しているような迅速な変化についていくのであれば、ソフトウェアエンジニアも俊足でなければならない。

アジャイルは変化に効果的に対応するだけではなく、本章のはじめに述べた宣言における哲学も含んでいる。より円滑に（チームメンバー、技術とビジネス担当者、ソフトウェアエンジニアとマネージャ間の）コミュニケーションを取れるチーム体制や態度を奨めている。動作するソフトウェアを短期間に納品することを重視し、（常に役に立つと限らない）中間成果物は重視していない。顧客を開発チームの一部と考え、多くのソフトウェアプロジェクトで蔓延し続けている「彼らは彼ら、私たちは私たち」という「人対人」の態度を排除している。不確実性をもつ世界における計画には限界が存在するため、プロジェクトの計画は柔軟でなければならないということを認識している。

アジャイルはすべてのソフトウェアプロセスに適用できるが、これを成し遂げるためには次の項目が不可欠となる。

- プロジェクトチームがタスクをこなし、それを能率化できるプロセスを設計すること
- アジャイル開発アプローチにおける流動性を考慮した計画策定を行うこと
- 必要不可欠な成果物以外を取り除いた、無駄のない状態に保つこと
- 動くソフトウェアを顧客へ短期間で送り届けるため、プロダクトの種類や運用環境にあわせたインクリメンタルなリリース戦略を重視すること


## 3.2 アジャイルと変化のコスト

（数十年の経験により支えられた）従来のソフトウェア開発を考えると、変化のコストはプロジェクトの進行にしたがって非線形に増える（図3.1の実線が対象）。プロジェクト初期においてソフトウェアチームが要件収集を行っている段階では、変化に適応することは比較的容易である。使用予定のシナリオを修正し、機能一覧の拡張を行い、仕様記述を編集するなどの必要が発生するが、これらのコストは小さく、作業に必要とされる時間はプロジェクトの成果に影響を与えないだろう。

それでは、数カ月先まで早送りしてみてはどうだろう。（プロジェクト終盤において実施されることの多い）妥当性評価テストのど真ん中において、重要なステークホルダが主要機能の変更を求めている。この変更によってソフトウェアアーキテクチャ設計の修正、新しく3つのコンポーネントの設計および実装、他にも5つのコンポーネントの修正、新しいテストの設計などが必要である。コストは急増し、変更によりデグレのような意図しない副作用がないことを確かめる時間および工数は、些細なものではない。

```
図3.1  変更コストとプロジェクトの進行との関係

Development Cost  開発コスト
Development Schedule progress  開発スケジュール上の進捗

Cost of change using agile process  アジャイルプロセスにおける変更コスト
Cost of change using conventional software process 従来のソフトウェアプロセスにおける変更コスト
Idealized cost of change using agile process  アジャイルプロセスにおける理想的な変更コスト
```

よく設計されたアジャイルプロセスは変更コストの曲線を「平ら」にして（図3.1の点線が対象）、ソフトウェアプロジェクト終盤の変更に対してコストや時間の劇的な影響がなくチームが対応できるようになると、アジャイルの提案者は述べている（例として[Bec99]や[Amb04]）。アジャイルプロセスではインクリメンタルなリリースを行うことはすでに理解しているだろう。インクリメンタルなリリースに（3.5.1節で簡易に、20章にて詳細に記述する）継続的なユニットテストやペアプログラミングのような他のアジャイルプラクティスを組合せることで、変更コストは減少する。変更コストの曲線が平らとなることについての議論は今も続いているが、変更コストを大きく削減できたことが文献[Coc01a]にて示されている。


## 3.3 アジャイルプロセスとは何か

多くのソフトウェアプロジェクトにて見られる次の前提[Fow02]に対して、アジャイルソフトウェアプロセスが解決を試みている。

1. どの要求が持続するか、変化するかを事前に予測することは難しい。また、顧客の優先順位がプロジェクトの進捗につれてどのように変化するかを予測することも等しく難しい。
2. 多くの種類のソフトウェアでは、設計と実装は、交互に行われる。設計モデルは実装されることで証明されるため、双方のアクティビティを行き来すべきである。証明するために実装されなければ、その設計がどれくらい必要であるかを予測することは困難である。
3. 分析、設計、実装、テストは（計画の段階では）予測できない。

これら3つの前提から「予測できないことをマネジメントするプロセスをどのように構築するとよいのだろうか」という疑問が浮かんでくる。答えは、すでに述べたように（プロジェクトや技術の急速な変化に対する）プロセスの適応性にある。アジャイルなプロセスとは、適応性が高くなければならないのだ。

しかしながら、前進せず変化に適応し続けるだけでは、何も達成できない。そのため、アジャイルソフトウェアプロセスは、インクリメンタルに変化への適応を行う。インクリメンタルな適応を成し遂げるために、アジャイルチームは顧客のフィードバック（つまりは適切な適応方法）を必要とする。動作するプロトタイプや操作可能なシステムの一部を活用することは、顧客からのフィードバックを得る有効な方法である。そのため、インクリメンタル開発における戦略を定めるべきだ。予測不可能な変化に対して一定の間隔でリズムよく適応するため、ソフトウェアのインクリメントとして実行可能なプロトタイプや操作可能なシステムの一部を短期間でリリースする。この反復的なアプローチによって、顧客によるソフトウェアインクリメントの評価が行われ、開発チームにとって必要なフィードバックが得られる。以上のプロセスにより、変化への適応がもたらされる。


### 3.3.1 アジャイルの原則

アジャイルアライアンス[2]では、アジャイルを目指す組織へ12の原則[Agi17]が定義されている。これらの原則を次の文でまとめる。

[2] アジャイルアライアンスのホームページでは、多くの有用な情報がある。
リンク：https://www.agilealliance.org/

できる限り短時間で顧客へとリリースされたソフトウェアを通じ、価値を提供することで顧客満足は達成される。これを達成するために、アジャイル開発者は要求が変更されるということを認識しよう。ソフトウェアインクリメントを頻繁に送り届け、迅速かつ意味のあるフィードバックを得るため、すべてのステークホルダと一緒に働く。

アジャイルチームはフェイス・トゥ・フェイスで情報を伝達し、高品質のソフトウェア開発に貢献する環境で働く、意欲ある人々によって構成される。
チームは卓越した技術と優れた設計を実現できるプロセスに従い、シンプルであること、すなわち「無駄なくつくる量を最大にすること」[Agi17]を重視する。顧客のニーズと適合する動くソフトウェアが主要なゴールであり、チームの方向性や作業速度は効果的に長い期間業務できるよう「持続可能」でなくてはならない。

アジャイルチームは自己組織化されたチームである。自己組織化チームはうまく構造化されたアーキテクチャを構築し、確かな設計を行い、顧客満足を達成する。常に主要なゴールに向けてやり方を改善することを試み、業務のふりかえりを行うチーム文化を持つ。

<!--
★参考：↑は以下をサマライズした文書なので一部参照。

1. 顧客を満足を最優先し、価値あるソフトウェアを早く継続的にリリースする。
2. 開発の後半でも要求の変更を歓迎する。アジャイルプロセスは、顧客の競争優位性のために変化を味方につける。
3. 動くソフトウェアを数週間から数カ月、できる限り短期間で、頻繁にリリースする。
4. ビジネス側の人々と開発者は、プロジェクトをとおして日々一緒に働くべきである。
5. プロジェクトは、意欲ある人々によってつくられる。彼ら/彼女らに環境と必要な支援を提供し、仕事を成し遂げることを信頼せよ。
6. 効果的かつ効率的にチーム内で情報を伝達する方法は、フェイス・トゥ・フェイスで話すことである。
7. 動くソフトウェアが進捗に対するもっとも重要な尺度である。
8. アジャイルなプロセスは、持続可能な開発を促進する。スポンサー、開発者、ユーザは、一定のペースを継続的に維持ができるようにすべきである。
9. 卓越した技術と、優れた設計に着目し続けることが機敏さを高める。
10. シンプルであること、すなわち無駄なくつくる量を最大にすることが、本質である。
11. 最良のアーキテクチャ、要求、設計は、自己組織化されたチームから生まれる。
12. チームはより効率を高める方法を定期的にふりかえり、それに基づいて行動を最適化する。

-->

すべてのアジャイルプロセスモデルが本章で示す特徴を等しく重視している訳では無く、いくつかのモデルは一部の原則の重要性を無視（もしくは軽視）する選択をしている。だが、この原則は本章で示される各プロセスモデルの中に存在する「アジャイルの精神」を定義している。


### 3.3.2 アジャイル開発のポリシー

アジャイルソフトウェア開発は、従来のソフトウェアエンジニアリングプロセスと対照的であり、その利点と利用可能性は重要な議題となり、ときとして執拗なほど議論される。

Jim Highsmithは、冗談めいたたとえとして、アジャイル信奉者たちの考え方を極端な言葉を用い、「伝統的な方法論者とは、ビジネスのニーズを満たす動くシステムよりも、非の打ち所のないドキュメントをつくる、革新ぎらいの連中である」と評している[Hig02a]。反対に、これも冗談めいたたとえとして、伝統的なソフトウェアエンジニアリング派の考え方を、「軽量、いや『アジャイル』方法論者は、おもちゃを拡張して企業で利用するソフトウェアをつくり、驚かせようとしているハッカーたちを、過度に褒める連中だ」と述べている。

すべてのソフトウェア技術に関する議論と同様に、この方法論の論争は、宗教戦争に陥ってしまうリスクがある。ウォーターフォールの開発が崩壊するような場合には、合理的な思考が消え去り、事実よりむしろ信仰によって意思決定が促されてしまう。

だれも俊敏であることに反対はしない。ここでの疑問は、達成への最良の手段は何か、ということだ。動くソフトウェアが重要であることは心にとどめたうえで、信頼性、使用性、保守性を含めた品質特性の存在も忘れてはいけない。では、現在の顧客のニーズを満たし、さらに拡大するニーズを長期にわたって満たし続ける拡張ができるような、際立った品質のソフトウェアをどうしたら構築できるだろうか。

これらの質問に対する、正しい答えは存在しない。アジャイル自身のなかにさえ多くのプロセスモデル（3.4節および3.5節参照）が提案されており、俊敏さを妨げる問題に対する異なるアプローチをもつ。各プロセスモデルに「アイデア」（図2.1における「タスク」と呼ぶことをアジャイル信奉者は嫌がる）が含まれており、それらは従来のソフトウェアエンジニアリングから大きく逸脱している。それでも、多くのアジャイルの概念は、よいソフトウェアエンジニアリングの概念をシンプルに適用したものである。肝心なことは、複数のアプローチのよい点を考慮することで多くが得られ、いずれかのアプローチを批判することでは何も得られないということだ。


## 3.4 スクラム[訳注2]

<!-- 本節の用語はスクラムガイド参考 -->

[訳注2] 詳しくは最新の日本語版スクラムガイド（リンクは2020のもの）を読むことを推奨する。リンク：https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Japanese.pdf

スクラム[3]（Scrum：この名前はラグビー競技内の活動に由来して名付けられた）は、1990年代初頭にJeff Sutherlandとそのチームによって作られた、非常に有名なアジャイルソフトウェア開発手法である。さらにスクラムの手法はSchwabetとBeedle[Sch01b]によって拡張されている。

[3] プレイヤーの一団がボールを囲み、タッチダウンへ向けて（時に荒々しく！）協働する。

★evolutionって洗練なのか

スクラムの原則はアジャイルソフトウェア開発宣言と整合性がある。スクラムは要求、分析、設計、洗練、デリバリといったフレームワークアクティビティに対応したプロセスであり、開発をガイドする。それぞれのフレームワークアクティビティでは、比較的短い期間でタイムボックス[4]化された「スプリント」内でタスクが実行される。各フレームワークアクティビティ達成に必要なスプリント数は、プロダクトの複雑さや規模によって変化する。各スプリント内では目先の問題に対応できるように実施される作業が決定され、状況の変化にあわせてスクラムチームにて作業が修正される。スクラム全体のプロセスフローを図3.2にて示す。スクラムフレームワーク[5]に対する本書内の説明の多くはFowlerとSutherlandによってまとめられている[Fow16]。

[4] タイムボックスはプロジェクトマネジメント（4部参照）用語で、あるタスクを完遂するために割り当てられた期間のこと。

[5] スクラムガイド（原著）はこちらのリンクから読むことができる。リンク：https://www.scrum.org/resources/what-is-scrum

```
図3.2  スクラムのプロセスフロー

Product Backlog：Prioritized product features desired by the customer
プロダクトバックログ：優先付けされた顧客に望まれたプロダクトのフィーチャ
Sprint Backlog：Feature(s) assigned to sprint
スプリントバックログ：スプリントに割り当てられたフィーチャ
Backlog items expanded by team
チームによって詳細化されたバックログ項目
Scrum：15-minute daily meeting.
15分のデイリースクラム
every 24hours 24時間
30 days 30日間
New functionality is demonstrated at end of sprint
スプリントの完了時に新しいフィーチャがデモされる
```

### 3.4.1 スクラムチームと作成物

★ほぼ新規なので、文書なりは粗訳→清書にてチェックという手順とする。※対訳に注意★

スクラムチームはプロダクトオーナー、スクラムマスター、3～6名といった少人数の開発者（開発チーム）にて構成された自己組織化され、協働するチームである。スクラムにおける主要な作成物はプロダクトバックログ、スプリントバックログ、そしてコードのインクリメントである。スプリントと呼ばれる2～4週間の期間で行うインクリメンタルなプロトタイプ開発の単位へとプロジェクトを分割し、それぞれの開発を進める。

プロダクトバックログは、顧客にビジネス価値を提供するプロダクト要件もしくはフィーチャの優先づけられたリストである。プロダクトバックログアイテム（PBI：Product Backlog Item）[訳注3]は、プロダクトオーナーの承認やチームの合意によりいつでもバックログに追加できる。ステークホルダに対する最も重要なゴールへと向かうことができるよう、プロダクトオーナーはプロダクトバックログ内のPBIの優先順を決める。ステークホルダのニーズに合わせてプロダクトが進化し続けている限り、プロダクトバックログは決して完成しない。プロダクトオーナーは、インクリメントが受け入れられなかった場合においてスプリントを終了前に中止するか、延長させるかを決めることができる唯一の存在である。

[訳注3] プロダクトバックログはリスト、プロダクトバックログアイテム（PBI）は個々の要件（もしくはフィーチャ）となる。

スプリントバックログは、今回活動するスプリント期間内におけるコードのインクリメントとして、チームが完成させる想定で選択したPBIのサブセットである。インクリメントとは、これまでスプリントで完成したすべてのPBIに今回のスプリントで完成するPBIを合わせた（完成し、動作する）ものとなる。プロダクトオーナーと議論して今スプリント内で重要なゴールを達成するためのフィーチャを選び、それを実装したソフトウェアインクリメントを届けるために開発チームは計画を立てる。殆どのスプリントはタイムボックス化され、3～4週間で完了する。どのように開発チームがインクリメントを完成させるかは、チームの判断に任せる。いつインクリメントが完成し、プロダクトオーナーへデモをするかも開発チームが決定する。新しいスプリントが始まるまでは、スプリントバックログに新しいフィーチャは追加されない。

スクラムマスターは、スクラムチーム全員に対するファシリテーターとしての役割を持つ。スクラムマスターはデイリースクラムの開催を促し、その中でチームメンバーにより進捗を妨げるとみなされたものを排除する責任がある。また、開発者の手が空いた場合にスプリント内のタスクを完了させるためにお互い助け合うよう指導する。さらに、プロダクトオーナーがPBIを管理する方法を探す手助けをし、PBIが明瞭かつ簡潔に表現されるように支援する。


### 3.4.2 スプリントプランニング

まず最初に、開発チームとプロダクトオーナー、他のすべてのステークホルダの共同作業により、プロダクトバックログとするアイテムを用意する。なお、要件収集に関する技術は第7章に記述する。プロダクトオーナーと開発チームは、ビジネスニーズの重要性や完成へ向けて実施するソフトウェアエンジニアリングタスク（プログラミングやテスト）の複雑さを考慮してPBIを順番に並べる。この作業において、エンドユーザに機能を提供するために必要なフィーチャが抜けていることに気づく場合もある。

それぞれのスプリント開始前には、プロダクトオーナーはこれから実施するスプリントの成果であるインクリメントへ向けて開発のゴールを述べる。スクラムマスターと開発チームは、PBIを選択してスプリントバックログへと移動させる。開発チームはスプリントで割り当てられたタイムボックスという制約の中で、完成させるインクリメントを決定する。また、スクラムマスターとともにインクリメントを届けるために必要な作業を決める。さらに開発チームは必要とされる役割を考え、その役割を果たす方法を決める。


### 3.4.3 デイリースクラム

デイリースクラムは作業日の最初[訳注4]に予定された15分間のミーティングイベントである。このミーティングはチームメンバーのアクティビティを同期させ、次の24時間の作業を計画するために行う。スクラムマスターと開発チームは常にデイリースクラムに参加する。

[訳注4] 必ずしも朝に実施する必要はないが、毎日、同じ時間・場所で開催する。

チームメンバーは全員次の3つの質問に対して答える。

- 前回のデイリースクラムからやったことは何か？
- 障害となるものを目撃したか？
- 次回のデイリースクラムまでにやることは何か？

スクラムマスターはこのミーティングの開催を促し、各メンバーからの回答を吟味する。デイリースクラムはチームが早い段階で潜在的な問題に気付くために役に立つ。提示された障害を取り除くことはスクラムマスターのタスクである。これは可能な場合には次回のデイリースクラムまでに遂行する。このミーティングは問題解決会議ではない。問題解決はオフラインかつ必要なメンバーだけで集まって実施する。また、デイリーミーティングは「知識の共同化」[Bee99]にも繋がり、自己組織化されたチーム体制を促進する。

とあるチームでは、このミーティングにてスプリントバックログアイテム完成の宣言をしている。すべてのスプリントバックログアイテムを完成したとチームが判断した際には、完成したインクリメントのプロダクトオーナーを交えてのレビュー予定やデモ予定を決めることもある。


### 3.4.4 スプリントレビュー

スプリントレビューはスプリントの最後において開発チームがインクリメントが完成したと判断した場合に実施する。スプリントレビューは、4週間のスプリントの場合には4時間のレビューというようにタイムボックス化される。スクラムマスター、開発チーム、プロダクトオーナー、そして選ばれしステークホルダーが個のレビューに参加する。主要なアクティビティは、スプリントにて完成したソフトウェアインクリメントの「デモ」である。ここで重要な点として、計画したすべての機能をデモ対象としてはいけない。デモは、スプリントで定義されたタイムボックス内でリリースされた機能に対して実施する。


### 3.4.5 スプリントレトロスペクティブ

他のスプリントプランニングが始まる前に、スクラムマスターは開発チームと（4週間のスプリントの場合には）3時間ほどの「スプリントレトロスペクティブ」ミーティングの予定を立てる。このミーティングでチームは以下を議論する。

- うまくいったこと
- 改善すること
- 次のスプリント内で改善するためにチームがやること

スクラムマスターはこのミーティングにて、次のスプリントがより効果的となるようチームに開発プラクティスの改善をしてもらう。チームは改善や「完成」の定義を調整することにより、プロダクトの品質を向上させる方法を計画する。ミーティングが終わるまでに、チームは次のスプリントにおける改善案のアイデアを用意し、次のスプリントプランニングでのインクリメント計画へ向けて準備をする。


## 3.5 その他のアジャイルフレームワーク

ソフトウェアエンジニアリングの歴史は、いくつもの時代遅れのプロセスや方法論、モデリング手法や記法、ツール、技術に満ちあふれている。時代遅れの手法は悪評で炎上し、新しく、よりよいと（噂される）別の手法の影に隠れてしまう。ソフトウェア開発コミュニティに受け入れられるよう取り組んでいるが、さまざまなアジャイルプロセスフレームワークの導入につれて、アジャイルも同じ歴史的道筋を歩んでいる[6]。

[6] これは悪いことでない。多くのモデルや手法はデファクトスタンダードとなる前に、ソフトウェアエンジニアに心から受け入れてもらう必要がある。この「勝者」はベストプラクティスとして進化し、「敗者」は消えてなくなるか勝利したモデルに統合される。

前節で述べたように、最も広く使われているアジャイルフレームワークのひとつがスクラムである。だが、他にも多くのアジャイルプロセスモデルが提案され、組織にて使われている。本節ではXP、カンバン、DevOpsという3つのアジャイル手法について概要を示す。


### 3.5.1 XP（エクストリームプログラミング）フレームワーク

本項では、こちらも広く使われているアジャイルソフトウェア開発のアプローチであるXP（Extreme Programming）を紹介しよう。XPに対する影響力の強い書籍[Bec04a]をKent Beckが出版している。

XPは計画、設計、コーディング、テストという4つのフレームワークアクティビティにおけるルールとプラクティスから構成される。図3.3におけるXPのプロセス上で、それぞれのフレームワークアクティビティに関連する重要な概念とタスクを記した。XPにおける重要なアクティビティについて、次にまとめて示す。

```
図3.3  XPのプロセス

planning  計画
design  設計
coding  コーディング
testing  テスト

user stories  ユーザーストーリー
values  価値
acceptance test criteria  受け入れ基準
iteration plan  イテレーション計画

simple design  シンプルな設計
CRC cards  CRCカード

spike solutions  スパイクソリューション
prototypes  プロトタイプ

refactoring  リファクタリング
pair programming  ペアプログラミング

unit test  ユニットテスト
continuous integration  継続的インテグレーション

acceptance testing  受け入れテスト

Release  リリース

software increment  ソフトウェアインクリメント
project velocity computed  プロジェクトのベロシティ計算
```

#### 計画

計画アクティビティ（計画ゲームとも呼ばれる）は、「傾聴（listening）」と呼ばれる要件収集アクティビティからはじまる。この傾聴により、ソフトウェアに要求されるフィーチャや機能を記述したストーリー（ユーザーストーリーとも呼ばれる、第7章にて紹介）が作成される。

それぞれのユーザーストーリーは、顧客によってインデックスカードに書かれる。顧客は機能やフィーチャに対するビジネス上の価値に基づき、優先順位などの表現でユーザーストーリーへ価値を設定する[7]。XPチームのメンバーは、ストーリーを評価してコスト（見積りした開発期間）を設定する。重要なことは、新しいストーリーを作成することがいつでもできることである。

[7] とあるストーリーの価値は、他のストーリーに依存する場合もある。

顧客と開発者は、どのストーリーのグループを次のリリース（ソフトウェアインクリメント）に含めるかを決定する。

一度、次のリリースに向けて「コミットメント（リリースに含めるストーリー、リリース日、プロジェクトに関わるもの等に対する合意）」がなされると、XPチームは次の3つのうちいずれかの方法によってストーリを順番付けをして、開発を行う。

1. すべてのストーリを即座に（2～3週間以内で）実装する
2. もっとも価値の高いストーリを優先して実装する
3. もっともリスクの高いストーリーを優先して実装する

最初のリリース（ソフトウェアインクリメント）が納品された後、XPチームはプロジェクトのベロシティ（速度）を計算する。プロジェクトのベロシティとは、単純に最初のリリースで実装されたストーリーの数である。このベロシティは今後続くリリースにおけるリリース日とスケジュールの見積りに役立てる。XPチームはベロシティによる見積に応じて計画を修正する。


#### 設計

XPの設計はKIS（keep it simple：シンプルにせよ）の原則に厳密に従う。（開発者が後々必要になると予想して付け加えた）余計な機能の設計はXPでは推奨されない[8]。

[8] 洗練された設計記法や技術用語はシンプルな方法の中で得られる場合もあるが、これらの設計指針はソフトウェアエンジニアリングの手法に従うべきである。

XPではオブジェクト指向におけるソフトウェアを考える効果的な仕組みであるCRCカード（第8章参照）の利用を薦めている。CRC（クラス-責務-コラボレータ：class-responsibility-collaborator）カードは、現在のソフトウェアインクリメントに関連のあるクラス[9]を特定してまとめる。XPのプロセスにおいて、CRCカードは設計において作成される唯一の成果物である。

[9] オブジェクト指向におけるクラスの説明は、第2部全般にて示す。

ストーリーに対する設計にて困難な箇所が見つかった場合、XPではその箇所の操作可能なプロトタイプをすぐに実装することを薦めている。設計はコードを書く前にも後にも発生する、がXPの中心的な考えである。「ソフトウェアのふるまいを変えずにコードを修正および最適化する」[Fow00]、すなわちリファクタリングは構築しているシステムに対して継続的に設計し続けることを意味する。実際、構築アクティビティ自体が、XPチームがどのように設計を改善すべきかの方向付けをするのである。


#### コーディング

XPではストーリが構築され準備となる設計が完了した後、チームはコーディングに入るのではなく、現在のリリースに含まれる各ストーリーを確認するユニットテストを書くべきと薦めている[10]。ユニットテスト[11]が作られると、開発者はテストをパスするコードを実装することに集中することができる。コードが完成した時点でユニットテストが実行されることで、即座に開発者へとフィードバックが行われる。

[10] このアプローチは学習の前に試験問題を把握するようなものである。問われる問題にのみ集中することで、学習が非常に容易になる。

[11] 第20章で詳細を記すユニットテストは個々のソフトウェアコンポーネントを対象とする。コンポーネント内のエラーを発見するため、そのインタフェース、データ構造、機能をテストする。

コーディングにおける重要な概念（また、XPの目立つ特徴として語られるもの）は、ペアプログラミングである。XPは1つのPCを使って、2人の開発者が共同作業でストーリーのためのコードを書くことを薦めている。これは即時に問題解決（2つの頭脳は1つの頭脳に勝る）ができ、即時に品質保証をする（コードが書かれると同時にレビューされる）仕組みを提供する[12]。

[12] ペアプログラミングはWall Street Journalが1面で記事を紹介[Wal12]するなど、ソフトウェアコミュニティに大きく広がっている。

ペアプログラミングが完了した後、開発したコードは他の開発者のコードとインテグレーション（統合）される。「継続的インテグレーション」という戦略は、互換性やインタフェースに対するエラーの早期発見に役立つ。


#### テスト

ユニットテストは、容易かつ何度もテストするために、自動化が可能なフレームワークを用いて実装されるべきである。自動化によって、XPのリファクタリング哲学により頻繁に行われるコード修正の度にテストを実行するという、回帰テスト戦略（第20章参照）を実現できる。顧客テストとも呼ばれるXPの受け入れテストは、顧客が確認およびレビューできるシステムのフィーチャや機能に焦点をあてる。この受け入れテストは、ソフトウェアリリースとして実装されたユーザストーリーから導き出される。


### 3.5.2 カンバン

★調整が必要な用語：change management service delively、outcome、change、WIPの扱い★

カンバンの手法はあらゆるプロセスやワークフローの改善に使える、リーンな（無駄のない）方法論である。カンバンは変更管理とサービスデリバリに着目する。変更管理はソフトウェアシステムに要求された変更が統合される間のプロセスを定義する。サービスデリバリは顧客のニーズや期待を把握する重要性によって推奨される。チームのメンバは業務を管理し、完成させるための裁量が与えられる。アウトカム向上の必要性に応じてやり方は進化する。

```
図3.4  カンバンボード

Backlog  バックログ
Selected  選択されたバックログ
Analysis  分析
Development  開発
Testing  テスト
Done  完了

Expedite Lane  緊急レーン

Doing  作業中
Done  完了

```

★カードとアイテムが揺らいでわかりづらいので調整する★

カンバンはトヨタにおける産業エンジニアリングプラクティスを起源とし、David Andersonによってソフトウェア開発に採用された[And16]。カンバンは6つの中心となるプラクティスからなる。

1. カンバンボード（例を図3.4に示す）を用いてワークフローを見える化する。カンバンボードはソフトウェアの機能単位の開発ステージを示す列で構成される。ボード上の付箋を用いたカードには1つのユーザーストーリーもしくは現状判明している欠陥が書かれる。チームは「ToDo」から「作業中」さらには「完了」へと、プロジェクトの進捗に応じてカードを進める[訳注5]。

[訳注5] 図3.4では「選択されたバックログ」と書かれているが、本文の説明のように「ToDo」が列として使われることが多い。開発ステージ側の列タイトルを含めてチームで決めてよい。

2. いかなる時でも実施中の作業（WIP：Work in Progress）の数を制限する。開発者は他のタスクを開始する前に現在のタスクを完了することが求められる。これはリードタイムを減らし、業務の品質を改善し、ステークホルダへソフトウェア機能を短時間に届けるチームの能力を向上させる。

3. 現在のバリューフローを理解すること、停滞している箇所を分析すること、改善への変更方法を定義すること、そして変更する。これらによって無駄を減らすためにワークフローを管理する。

4. プロセスのポリシーを明確にする。（例：「作業するアイテムを選択した理由と『完了』を定義するための基準を書きとどめよ」）

5. プロセスデータに基づいて変更するフィードバックループを創出すること。また、プロセス上における変更の影響が測定されること。これらにより継続的な改善に集中する。

6. プロセスを共同して変更し、すべてのチームメンバーおよび必要なステークホルダを巻き込むこと。

カンバンにおけるチームミーティングはスクラムと似ている。現状動いているプロジェクトに看板を導入する場合には、すべてのカードをバックログ列から開始する必要はない。

開発者は次の質問に答える形でカードをチームのプロセスの列に置く必要がある。

- このカードはどこにいるのか？
- このカードはどこから発生したのか？
- このカードはどこへ行くのか？

★Walking the boardは確認★

毎日のカンバンスタンドアップミーティングは「ウォーキング・ザ・ボード」と呼ばれるタスクである。このミーティングのとりまとめ担当はローテーションさせる。チームメンバーは実際に取り組んでいるがボード上にないあらゆるアイテムを見つけ、ボードに追加する。チームはすべての実施可能なアイテムを前進させ、「完了」となるようにする。

ビジネス価値の高いアイテムを率先して前進させることがゴールである。チームはフローから作業負荷とリスクを確認することで完了へ向けた障害を特定する。

毎週のふりかえりミーティングにて、プロセスに対する測定結果を確認する。チームはプロセスのどこを改善する必要があるか検討し、実施する変更を提案する。カンバンは少しのルールや仕組みを追加することにより、容易に他のアジャイル開発プラクティスと組み合わせることができる。


### 3.5.3 DevOps

DevOpsは開発と運用を結びつけるためPatrick DeBoisによって提案された[Kim16a]。DevOpsはソフトウェア全体のサプライチェーンに渡って、アジャイルとリーンの原則を適用することを試みている。図3.5はDevOpsのワークフローの概要である。DevOpsのアプローチは目的のプロダクトが得られるまで継続的にループするいくつかのステージからなる。

#### 継続的開発

ソフトウェアの成果物は分解され、開発チームの品質保証[14]担当者におけるテストのためにもインクリメントが提供され、複数のスプリントで開発される。

[14] 品質保証については第17章にて議論する。

#### 継続的テスト

インテグレーション（統合）前に欠陥がないことをチームメンバーが確認するため、複数のコードインクリメントを同時にテストする自動テストツール[15]が使用される。

[15] 自動テストツールについては第19章にて議論する。

#### 継続的インテグレーション

新しい機能を含むコードが既存のコードおよび実行環境に加えられ、デプロイ後にエラーが出ないようにチェックされる。

#### 継続的デプロイ

このステージでは、統合されたコードが本番環境へデプロイ（インストール）される。新しい機能を追加する必要のある本番環境は、グローバル展開により複数のサイトがある場合もある。

#### 継続的モニタリング

開発チームの一員である運用スタッフが、本番環境におけるパフォーマンスの測定や、潜在的な問題をユーザが見つける前に積極的に発見することにより、ソフトウェア品質の向上を支援する。

```
図3.5  DevOps

Plan  計画
Code  コード
Build  ビルド
Test  テスト
Integrate  インテグレーション
Deploy  デプロイ
Operate  運用
Monitor  モニタ
```

DevOpsは顧客のニーズや要望に対して迅速に反応して変化させることにより、顧客体験を向上させる。このことによってブランド・ロイヤルティを高め、マーケットシェアを増やすことができる。DevOpsのようなリーンなアプローチは、繰り返し作業を減らし、より高いビジネス価値へとつながる活動ができるようにすることで、組織がよりイノベーションを創出できるようにする。顧客がアクセスするまでプロダクトは金を生まない、DevOpsは顧客が触れる本番環境へデプロイするまでの時間を短時間とする。


## 3.6 まとめ

★表2.1と同じく、原著の表から見やすいように表構造を変更してます★

<!-- textlint-disable -->
表3.1 アジャイル技法の比較

| プロセス名 | ポジティブ | ネガティブ |
| :--- | :--- | :--- |
| スクラム | プロダクトオーナーが優先順位を決める<br>チームが自分たちで意思決定をする<br>ドキュメントが軽量である<br>頻繁なアップデートをサポートする | 変更のコストを制御することが難しい<br>大規模チームには適さない場合がある<br>エキスパートなチームメンバーを必要とする |
| XP | 顧客を巻き込むことを重視する<br>本質的な計画とスケジュールを作成する<br>プロジェクトへの開発者の強いコミットメントがある<br>プロダクトが却下される可能性を低くする | プロトタイプをリリースする誘惑にかられる<br>コストの増加に対して頻繁なミーティングが必要<br>変更がやりすぎとなる場合がある<br>スキルの高いチームメンバーに依存する |
| カンバン | 導入に必要な費用と時間が少ない<br>プロダクトのリリースを短期間にする<br>プロセスポリシーを書きとどめる<br>継続的にプロセスを改善する | チームの協力する力が成功を決める<br>貧弱なビジネス分析がプロジェクトに破滅をもたらす<br>柔軟性により開発者が目的を失うことがある<br>開発者が測定することをしぶる　 |
| DevOps | デプロイまでの時間を短縮する<br>開発者と運用者が1つのチームとなる<br>チームがEnd-to-Endのプロジェクト所有権を持つ<br>デプロイされたプロダクトを積極的にモニタする | 新旧のコード双方を扱う業務は困難となる<br>効果的になるだろう自動化ツールを強く信頼する<br>開発が本番環境に悪影響を及ぼす可能性がある<br>エキスパートな開発チームが求められる |

<!-- textlint-enable -->

現代の経済において市場の変化は速く、顧客やエンドユーザはよりよいものを求め、新しい競合が警告もなく出現する。昨今のビジネスニーズに応えることができるよう変化に適応し、実現可能で、無駄がないプロセスを実現するためには、アジャイル（迅速）であるためのソフトウェアエンジニアリングアプローチを実践しなければならない。

ソフトウェアエンジニアリングにおけるアジャイルの概念は次の4つを重視する。アジャイルプロセスモデルは、これらを考慮して設計されている。
* 自らの業務を管理する自己組織化されたチームの重要性
* チームメンバー間、開発者と顧客間のコミュニケーションおよび協調
* 変化は機会であるという認識
* 顧客を満足させるソフトウェアを短期間でリリースすることをの重要性

図3.1に今回取り上げたアジャイル技法のポジティブ要素とネガティブ要素をまとめる。本書の前版では、より多くの技法について触れている。どのアジャイル技法もあらゆるプロジェクトに対して万能ということはない。アジャイル開発者は、決定権を持つチームで働き、自身のプロセスモデルを作る権限が与えられる。

スクラムは、厳しい時間設定、要件の変更、ビジネスに対して重要なプロジェクトに対して効果的であると示されたソフトウェアプロセスパターンを使うことに重点をおく。デイリースクラムやスプリントプランニングのミーティングに役立つ仕組みとなるカンバンボードをスクラムチームが使わない理由がない。

XPは計画、設計、コーディング、テストという4つのフレームワークアクティビティから構成される。XPでは、ステークホルダによって優先順位をつけられたフィーチャや機能を頻繁にリリースするための、革新的で強力なテクニックを提案している。デプロイまでの時間を短縮するためにDevOpsの技術を使用することを妨げるものは何もない。


## 問題と考察のポイント

3.1 本章の冒頭にある「アジャイルソフトウェア開発宣言」[Bec01]を読み直し、4つの「価値」（どれか1つでもよい）がソフトウェアチームに困難をもたらす状況が存在するか考えよ。

3.2 （ソフトウェアプロジェクトにおける）アジャイル、俊敏さについて自分の言葉で説明せよ。

3.3 なぜ、反復プロセスが変更の管理を容易にするのか。本章で記載されたすべてのアジャイルプロセスは反復的か。一度の反復だけでプロジェクトを完遂することは可能か。それはアジャイルといえるか。考えを説明せよ。

3.4 ソフトウェアエンジニアリングチームをより機敏にする「アジャイルの原則」をもうひとつ提案せよ。

3.5 なぜ要求は頻繁に変更されるのか。つまり、何が欲しいかを人はわからないのか。考えを説明せよ。

3.6 殆どのアジャイルプロセスモデルは、面と向かってのコミュニケーションを推奨している。しかし、ソフトウェアチームと顧客は地理的に離れている場合もある。この地理的な分散は避けるべきだと考えるか。また、この問題を克服する方法を考えよ。

3.7 殆どのウェブブラウザで使用可能な「お気に入り（ブックマーク）」のフィーチャをユーザストーリで記述せよ。

3.8 XPにおけるリファクタリングとペアプログラミングの概念を説明せよ。

<style scoped>
.index {color: green; }
</style>
