# 第2章　プロセスモデル

ソフトウェア開発は社会的な反復型学習プロセスである．プロセスの実行により知識が抽出され集積される．さらに体系化され具現化することで，Baetjerが「ソフトウェア資産」と呼ぶ[Bae98]成果物が生み出される．

技術的な見地からすると，ソフトウェアプロセスとは何を示すのか．本書ではソフトウェアプロセスを高品質のソフトウェアを開発するために必要なアクション，タスクから構成されるフレームワークであると定義する．それでは，プロセスとはソフトウェアエンジニアリングと同じ意味だろうか．答えは，YESでありNOでもある．ソフトウェアプロセスは，ソフトウェア開発の際に採用するアプローチを決める．一方，ソフトウェアエンジニアリングも技術的手法や自動化ツールといったプロセス内で使用する技術を提供する．

重要なのは，創造的で見識にあふれた人々によって，プロダクトの特徴や市場の需要に適した成熟したプロセスに従ってソフトウェエンジニアリングが行われるべきだ，という点である．

## 2.1 一般的なプロセスモデル


プロセスは成果物が生み出される際に実施される一連のアクティビティ，アクション，タスクであると1章にて定義した．これらアクティビティ，アクション，タスクはモデルやフレームワーク表現を用いてプロセスとの関連性が表される．

ソフトウェアプロセスを図2.1にて模式的に示す．図2.1のように，各フレームワークアクティビティはいくつかのソフトウェアエンジニアリングアクションを伴っている．各ソフトウェアエンジニアリングアクションは，1つのタスクセットによって定義される．タスクセットは，完遂されるべきタスク，生み出される成果物，求められる品質評価ポイント，進捗を示すためのマイルストンを特定する．

```
図2.1：ソフトウェアプロセスフレームワーク
あああ
```

第1章で論じたように，ソフトウェアエンジニアリングの一般的なプロセスフレームワークは5つのフレームワークアクティビティを定義している．コミュニケーション，計画策定，モデリング，構築，デプロイである．あわせて，ソフトウェアプロジェクトの追跡と管理，リスクマネジメント，品質保証，構成管理，テクニカルレビューといった包括的なアクティビティがプロセス全体に適用される．

ここではソフトウェアプロセスの重要な側面がまだ議論されていない．「プロセスフロー」は，フレームワークアクティビティ内でアクティビティ，タスク，アクションがどのような順序，時系列で発生するかの体系を示す．図2.2にプロセスフローを図示する．

```
図2.2：プロセスフロー
あああ
```

図2.2a「リニアプロセスフロー」では，5つのフレームワークアクティビティは順番に実行される．コミュニケーションから始まり，デプロイで締めくくられる．図2.2b「反復プロセスフロー」では，とあるアクティビティの前段階アクティビティが繰り返される．図2.2c「進化型プロセスフロー」では循環的にアクティビティが実行される．アクティビティの循環により，よりよいソフトウェアバージョンが生み出される．図2.2d「パラレルプロセスフロー」では，あるアクティビティと並行して他のアクティビティが実行される．ソフトウェアの一部分に対するモデリングは，ソフトウェアの他部分の構築と並行して実行される．


--- ここまでチェック済 ---

## 2.2 フレームワークアクティビティの定義

2章にて5つのフレームワークアクティビティを取り上げ基本的な定義を行ったが，ソフトウェアプロセスとしてこれらアクティビティを正しく実行しようとすると，ソフトウェアチームはより多くの情報が必要となるだろう．つまり，「解決すべき問題の本質，業務に取り組む人々やプロジェクトのスポンサーとなるステークホルダの特徴にあわせて，どのようなアクションがフレームワークアクティビティとして適しているのか」という重要な疑問に直面するのである．

a) リニアプロセスフロー
b) 反復プロセスフロー
c) 進化型プロセスフロー
d) パラレルプロセスフロー

リモート開発など一人で行うような複雑でもない要求を扱う小さなソフトウェアプロジェクトにおいては，コミュニケーションのアクティビティは特定のステークホルダとの電話やEメールでのやり取りにすぎない．つまり，唯一必要とされるアクションは，電話での会話および次の作業タスク（タスクセット）である．

1. ステークホルダと電話にてコンタクトを取る．
2. 要求を議論して記録する．
3. 記録を整理して，端的な要件記述を作成する．
4. Eメールでステークホルダにレビューを依頼をし合意を取る．

プロジェクトにおいて多数のステークホルダがいて，各ステークホルダが一部対立を含むような異なる要求を持っている複雑な状況では，コミュニケーションのアクティビティは6つの明確なアクションが必要となる．（第8章参照）これらのアクションは，開始(inception)（inception），要求獲得(elicitation)，推敲(elaboration)，交渉(negotiation)，仕様(specification)，検証（validation）である．これらのソフトウェアエンジニアリングアクションについては，多数の作業タスクと明確な成果物を有する．


## 2.3 タスクセットの特定

図2.1について再度確認しよう．各ソフトウェアエンジニアリングアクション（「要求獲得(elicitation)」を例にした場合はコミュニケーションアクティビティに関連したアクションとなる）は，成果物，品質保証ポイント，プロジェクトマイルストンに関連する作業タスクの集合体であるタスクセットによって表現される．

★もうちょい文書有★

```
タスクセット

タスクセットは，ソフトウェアエンジニアリングのアクションの目的達成に向けた実作業と定義する．たとえば，誘発（一般的には「要件収集（requirements gathering」と呼ばれる）はコミュニケーションのアクティビティ内で発生する重要なソフトウェアエンジニアリングアクションである．開発するソフトウェアに対してのさまざまなステークホルダの期待を理解することが要件収集のゴールである．

比較的単純で小さいプロジェクトでは，要件収集におけるタスクセットは以下となる．

1. プロジェクトにおけるステークホルダのリストを作る
2. ステークホルダを非公式的な会議に招待する
3. 各ステークホルダに要件となる機能やフィーチャのリストを作るため質問をする
4. 要件を議論し，最終的なリストを構築する
5. 要件の優先順位をつける
6. 不明確な部分を注記する

規模が大きく，より複雑なソフトウェアプロジェクトでは，次に示すような異なるタスクセットが必要とされる．

1. プロジェクトにおけるステークホルダのリストを作る
2. 各ステークホルダに個別にインタビューを行い，ニーズの全体像を決める
3. ステークホルダの情報に基づいた機能やフィーチャの暫定的な要件リストを作る
4. アプリケーションの仕様調整を進める一連の会議を設定する
5. 会議を実施する
6. 会議の一部で非公式のユーザシナリオを作成する
7. ステークホルダのフィードバックによってユーザシナリオを洗練させる
8. ステークホルダの要件リストを改訂する
9. 品質機能展開（QFD）の技術を用いて，要件の優先順位をつける
10. 段階的にリリースできるように要件をパッケージ化する
11. システムにおける制約や制限事項を注記する
12. システムの妥当性を確認する方法を議論する

前者および後者のタスクセットは共に要件収集を達成するものであるが，活動の深さと形式的手続きの度合いが大きく異なる．各アクションのゴールを達成し，品質と俊敏性を確保し得るタスクセットをソフトウェアチームは選択する．
```


## 2.4 プロセス評価と改善

ソフトウェアプロセスが存在するからといって，ソフトウェアが納期に納品され，顧客ニーズを満たし，長期的な品質を技術的に確保できる，という保証はない（第第19章参照）．プロセスパターンは確固たるソフトウェアエンジニアリングの実践とともに存在しなければならない（本書2部参照）．さらに，ソフトウェアエンジニアリングを成功させるために必要不可欠な基本的なプロセス基準を確実に満たすよう，プロセス自体も評価されねばならない[*1]．

[*1] SEIのCMMI@<bib>{CMM07}では，ソフトウェアプロセスの特徴とその成功に向けた豊富かつ詳細なプロセス基準を記している．

★もうちょい追加文書有★


## 2.5 規範的なプロセスモデル

規範的なプロセスモデル[*2]は，ソフトウェア開発における構造と秩序を指向する．プロセスに定義された進捗ガイドに従い，アクティビティやタスクは順次処理をする．しかし，変化に晒されるソフトウェアの世界において規範的プロセスモデルはふさわしいのだろうか．伝統的なプロセスモデル（およびそのモデルによる秩序）が否定され，より構造化されていない何かにプロセスが置き換えられた場合，ソフトウェア業務における協調や一貫性の維持は不可能とはならないだろうか．

[*2] 規範的なプロセスモデルは，「伝統的な」プロセスモデルと呼ばれる時もある．

これらの問いに簡単な答えはないが，ソフトウェアエンジニアにはいくつかの選択肢が存在する．本章では，秩序とプロジェクトの一貫性の維持を第一に考える規範的なプロセスのアプローチについて考察する．これらを「規範的」と呼ぶのは，どのプロセスも一連のプロセス要素──フレームワークアクティビティ，ソフトウェアエンジニアリングアクション，タスク，成果物，品質保証，および変更管理の仕組みをプロジェクトで規定しているためである．各プロセスモデルは，プロセスフロー（ワークフローとも呼ばれる）を規定している．つまり，各プロセス要素は他の要素と相互関係をもつのである．

あらゆるソフトウェアプロセスには，第2章章および第3章で述べた一般的なフレームワークアクティビティが含まれる．しかし，プロセスによってどのアクティビティを重視するかは異なり，各フレームワークアクティビティ（およびソフトウェアエンジニアリングアクションとタスク）におけるプロセスフロー定義も異なる．

### 2.5.1 ウォーターフォールモデル

ある問題に対する要求が十分理解されていて，コミュニケーションからデプロイまで順序的に作業を実施できる場合がある．こうした状況は，明確に定義された既存システムの修正や拡張（たとえば，政府の規制変更により必ず実施しなければならない会計ソフトウェアの修正など）で発生する場合がある．また，一部の新規開発でも，要求が明確に定義されており，変更があまり起こらないことは同様に起こり得る．

ウォーターフォールモデルは，線形逐次型モデルと呼ばれることもある．これは顧客の要求定義から始まり，計画策定，モデリング，構築，デプロイと進み，完成したソフトウェアの継続的なサポートの実施にいたるまでのソフトウェア開発の体系的かつ逐次型のアプローチ[*3]である．

[*3] ★Winston Royce★ @<bib>{Roy70} によって提案された本来のウォーターフォールモデルは「フィードバックループ」を考慮しているのだが，このプロセスモデルを適用した組織の大部分は，厳密な逐次型プロセスとして扱ってしまった．

```
図2.3：ウォーターフォールモデル
Communication：コミュニケーション
　プロジェクト開始，要件収集
Planning：計画策定
　見積もり，スケジュール，追跡管理
Modeling：モデリング
　分析，設計
Construction：構築
　プログラム，テスト
Deployment：デプロイ
　リリース，サポート，フィードバック
```

ウォーターフォールモデルは，ソフトウェアエンジニアリングにおけるもっとも古いパラダイムである．しかし，50年以上が経過し，積極的に支持していた人々でさえ，今では有効性に疑問を抱くようになった．ウォーターフォールモデル適用時の問題には，次のようなものがある．

1. 現実のプロジェクトでは，モデルに示されている順番どおり進行することはほとんどない．反復的な作業にも対応できるが，単純にできるようなものではない．結果として，プロジェクトが進捗するほど，変更が混乱を招いてしまう．
2. 顧客が要求事項をすべて明確に述べることは難しい．ウォーターフォールモデルではすべての要求事項を明確にすることを求めるため，プロジェクト開始時に当たり前のように存在する不確実性への対応が困難となる．
3. 顧客は辛抱強く待っていなければならない．実際に動作するプログラムは，プロジェクトの後半になるまで入手できない．
4. プログラムがレビューされず，動く段階になって初めて大きな問題が発見された場合，悲惨な結果になる可能性がある．

今日，ソフトウェア業務はスピードが求められ，（機能やフィーチャ，情報コンテンツの）変更の奔流に晒されている．ウォーターフォールモデルは，こうした状況には適していない場合が多い．


### 2.5.2 プロトタイピング

顧客はソフトウェアの大まかな目的は定めたとしても，機能やフィーチャの詳細まで決めないことが多い．逆に開発者は，アルゴリズムの効率，オペレーティングシステムの適合性，ユーザインタフェースの使いやすさに自信のない場合がある．こうした場合には，プロトタイピングのパラダイム（prototyping paradigm）が最良のアプローチとなるだろう．

プロトタイピングは単独のプロセスモデルとしても適用できるが，本章で述べる他のプロセスモデル内で利用できる技術として扱われる方が一般的である．どこに適用されるかは関係なく，要求があいまいな場合にプロトタイピングを用いることで，何を開発すべきかを他のステークホルダと理解を深めることができる．

★もうちょい追加文書有★

```
図2.4：プロトタイピングパラダイム
・・・
```

プロトタイピングパラダイム（図2.4参照）は，コミュニケーションから始まる．ソフトウェア技術者とステークホルダが顔を合わせ，ソフトウェアの全体的な目標を定める．その時点で思いつく要求事項をすべて明らかにし，さらに決定の必要がある部分は概要を作成する．迅速にプロトタイピングの計画を策定し，（「クイック設計」という形式で）モデリングが行われる．クイック設計では顧客が確認できる部分（ユーザインタフェースのレイアウトや出力形式など）に焦点を当てる．これによってプロトタイプができあがり，さらなる洗練へ向けたフィードバックのためにステークホルダの評価を受ける．さまざまなステークホルダのニーズを満たし，エンジニアが開発すべきことをより理解するためにプロトタイプが使われ，反復が行われる．

理想としては，プロトタイプはソフトウェア要求を明らかにするためだけの仕組みである．実際に動作するプロトタイプをつくる場合，既存のプログラムの一部を利用したり，動くプログラムを手早く生成できるツールを用いる．

ステークホルダとエンジニアは双方ともプロトタイピングを好む．ユーザは実際のシステムの感触を得ることができ，エンジニアはただちに動くものを構築できるからである．しかしプロトタイピングは，次の理由により問題を引き起こす可能性がある．

1. プロトタイプは行き当たりばったりで間に合わせで作られたものであり，総合的な品質や長期の保守性を考慮せず急ぎで動く状態にしたことを意識せず，すぐ動くバージョンであるとステークホルダが考えてしまいがちである．高い品質を維持するためプロダクトを開発し直す必要があることを伝えると，ステークホルダは非難の声を上げ，「ちょっとした修正」でプロトタイプをプロダクトにするよう求める．ソフトウェア開発側のマネージャもそれに同調してしまうことはとても多い．
2. ソフトウェアエンジニアもプロトタイプを短時間で動くようにするため，実装面で妥協することが多い．手軽に利用できるとか，ただ知っているからというだけで，適切でないオペレーティングシステムやプログラミング言語を使うことや，デモを見せるためだけに効率の悪いアルゴリズムで実装することがある．時間が経つとエンジニアは動くことだけで満足してしまい，なぜ不適切だったかの理由をすべて忘れてしまうこともある．そして，理想とはほど遠い選択結果がシステムの主要な部分を占めてしまうことになる．

いくつか問題はあるが，プロトタイピングはソフトウェアエンジニアリングにおける有効なパラダイムである．重要なことは，最初にゲームのルールを決めておくことである．つまり，要求を定義するための仕組みとしてプロトタイプを構築するということを，あらゆるステークホルダが同意すべきである．プロトタイプは少なくとも部分的には廃棄され，品質確保の視点で実際のソフトウェアが開発されるのである．


### 2.5.3 進化型プロセスモデル

他の複雑なシステム同様，ソフトウェアは長い期間をかけて進化するものである．開発が進むにつれてビジネスやプロダウトに対する要求が変化するため，最終プロダクトへとまっすぐ突き進むことは現実的でない．市場における競合やプレッシャーのある厳しい納期制約においては，ソフトウェアをすべて完成させることは不可能となっているため，ソフトウェア全体でなく限られたバージョンまずは出荷せざるを得ない．コアとなるプロダクトやシステムの要求事項は明確だが，その詳細や拡張についてはハッキリしていない状況もある．これらに近い状況では，成長し変化するプロダクトに適応するためのプロセスモデルが必要となる．

★Barry Boehm★ @<bib>{Boe88} が最初に提案したスパイラルモデル（spiral model）は，反復型のプロトタイピングモデルと体系的で統制された側面をもつウォーターフォールモデルを組合せた進化型のプロセスモデルである．このモデルでは，徐々に価値の高いソフトウェアを迅速に開発できる特徴がある．

スパイラルモデルを用いることで，進化型のソフトウェア開発が行われる．この開発イテレーション（反復の1つ分）における初めの成果物は，紙に描かれたモデルやプロトタイプの場合もある．後半の開発イテレーションでは，実際のプロダクトが徐々にできあがっていく．

スパイラルモデルは，エンジニアリングチームにより定義される一連のフレームワークアクティビティに分割される．説明のため，前述した一般的なフレームワークアクティビティを用いてみよう[*4]．各々のフレームワークアクティビティは，図4.5のらせん（spiral）上の一区画で表される．スパイラルモデルでは，らせんの中心から時計回りに作業を進めていく．作業の進捗に合わせて，リスク（第26章）が検討される．らせん上の区画には固定マイルストン──らせんに沿って実施される作業の成果物と達成条件を組合せたもの──が定義されている．

[*4] 本項で解説するスパイラルモデルは，Barry W. Boehmによって提唱されたモデルに手を加えたものである．本来のスパイラルモデルについての詳細は，参考文献@<bib>{Boe88}を参照のこと．また，Barry W. Boehmのスパイラルモデルについての最新の論考についても参考文献[8]を参照のこと．

```
図2.5：典型的なスパイラルモデル
・・・
```

第1サイクル（XX）ではプロダクト仕様が開発される．以降，らせんを1周するたびにプロトタイプ，プロダクト，さらに改良されたプロダクトが順次開発される．計画された区画を通過するたびに，プロジェクトの計画は調整される．リリース後の顧客からのフィードバックにもとづいてコスト，スケジュール，ソフトウェアを完成させるために必要なイテレーションの回数を調整する．

ソフトウェアがリリースされたら完了する他のプロセスモデルと異なり，スパイラルモデルはコンピュータソフトウェアライフサイクル全体に適用できる．スパイラルモデルは，大規模なシステムやソフトウェアの開発に対する現実的なアプローチである．プロセスの進捗とともにソフトウェアが成長していくため，開発者と顧客は徐々に理解を深め，リスクに対応することができる．スパイラルモデルでは，プロジェクトのすべての段階において技術的リスクを考慮することが要求されるので，適切に適用することでリスクを回避できるはずである．

しかし他のパラダイムと同じように，スパイラルモデルも万能ではない．進化型アプローチで開発の統制をとることができることを顧客に納得させることは難しく，契約が絡む場合には特に困難であろう．スパイラルモデルではリスク評価についての深い知識や技術が必要であり，成功もしくは失敗はそれに依存している．主要なリスクを発見し管理できないならば，間違いなく問題が起こるだろう．

現代のソフトウェアは，継続的な変更，非常に厳しいスケジュール，および顧客やユーザの満足が強く求められるという背景から特徴づけられていることはすでに述べた．多くの場合，市場に出るまでの時間（time-to-market）は最重要マネジメント要素である．もしマーケット投入時期を逃すと，プロジェクトそのものが無意味なものとなりかねない[*5]．

[*5] 市場において最初のプロダクトであることは，必ずしも成功を保証するものではない．実際，成功したソフトウェアプロダクトの多くは，2番手もしくは3番手で市場に登場している（先行したプロダクトの失敗から学んでいるということである）．

進化型モデルの目的は，高品質のソフトウェア[*6]を，反復もしくはインクリメンタルな方法で開発することである．しかし，進化型プロセスを用いて，柔軟性，拡張性，および開発速度を高めることも可能である．ソフトウェアチームとそのマネジャーは，プロジェクトとプロダクトにおける重大な調整項目や（ソフトウェア品質を決定する究極の要素である）顧客の満足度の間で，適切なバランスをとることに挑戦しているのである．

[*6] ここでは，ソフトウェア品質を広い意味で定義している．顧客満足だけではなく，本書の第2部で論ずる技術的な判断基準も含めた意味をもつ．


### 2.5.4 統一プロセス

ある意味，統一プロセスは伝統的なソフトウェアプロセスモデルにおける優れた特徴や性質を引き出そうとしているが，アジャイルソフトウェア開発（第5章参照）の優れた原則の多くも実装しているという特徴をもつ．統一プロセスは，顧客とのコミュニケーション，並びに顧客視点でシステムを記述する合理的な手法であるユースケース[*7]を重要視している．また，ソフトウェアアーキテクチャの重要性を強調しており，「アーキテクトが理解容易性，将来の変更への対応，および再利用のような正しいゴールへ集中できるようにしている」@<bib>{Jac99}．統一プロセスでは反復およびインクリメンタルなプロセスフローを提唱し，現代のソフトウェア開発には不可欠な進化型の考え方を取り入れている．

[*7] ユースケース（第8章参照）は，ユーザから見たシステムの機能やフィーチャを記述したテキスト文，あるいはテンプレートである．ユースケースはユーザによって書かれ，より包括的な分析モデルを作る基盤となる．

★以下2文書は混ざった形式となる★

1990年代初期において，★James Rumbaush★@<bib>{Rum91}，Grady Booch@<bib>{Boo94}，★Ivar Jacobson★[34]は，各自が提唱するオブジェクト指向分析や設計手法の優れた特徴を組合わせ，オブジェクト指向モデリングの有識者によって提唱されているその他方法（例：@<bib>{Wir90}）を取りこんだ「統一手法」に取り掛かった．その成果が，オブジェクト指向システムのモデリングと設計のための強力な表記法を有する統一モデリング言語（unified modeling language：UML）である．1997 年には，UML はオブジェクト指向ソフトウェア開発における業界標準となった．

本書第2部全般で要求および設計モデルの表記法としてUMLを使用している．基本的なUML記述やモデリングルールに慣れていない読者にAppendix1のチュートリアルを用意している．UMLの包括的な内容については，UMLについての教科書に譲る．推奨書籍はAppendix1のリストを見るとよい．

★ここまで★

図2.6は，統一プロセスの「フェーズ（phase）」を示したもので，第1章および本章の最初で述べた一般的アクティビティと関連付けている．

```
図2.6：統一プロセス
・・・
```

統一プロセスの「方向づけ（inception）フェーズ」は，顧客とのコミュニケーションおよび計画策定のアクティビティから構成される．ステークホルダと協力して，ソフトウェアのビジネス的な要求を明らかにし，システムの大まかなアーキテクチャを検討し，以降のプロジェクトの反復，およびインクリメンタルな作業の計画を作成する．基本的なビジネス要求は，主要なタイプのユーザがそれぞれどのようなフィーチャ，機能を求めているかを記述した一連の暫定的なユースケース（第8章参照）によって表現される．この時点では，アーキテクチャといっても，主要なサブシステムの大まかな区分けと，それぞれのフィーチャや機能が仮決めされているにすぎない．以降の作業で，アーキテクチャは洗練，拡張され，システムの異なるビューを表す一連のモデルとなる．計画策定では，リソースを識別し，主要なリスクを評価し，スケジュール定義を行い，ソフトウェアのインクリメントを構築する際に適用すべきフェーズの構想を行う．

推敲（elaboration）フェーズは，一般的なプロセスモデルにおけるコミュニケーションとモデリングのアクティビティから構成される（図4.7参照）．推敲では，方向づけフェーズで作成した暫定的なユースケースを洗練し，拡張する．また，アーキテクチャ表現も拡張され，5つの異なるビュー（ユースケースモデル，分析モデル，設計モデル，実装モデル，デプロイモデル）を含むものになる．推敲フェーズでは，実行可能な「最初の（First cut）」システムとして，「実行可能なアーキテクチャベースライン」[5]を作成することもある[*8]．アーキテクチャベースラインは，そのアーキテクチャが実現可能であることを示すものであるが，システムの利用に必要なすべてのフィーチャや機能は実装していない．また，推敲フェーズの完了時にはプロジェクト計画を注意深くレビューし，スコープ，リスク，リリース日が妥当なものであるかを確認する．この時点で計画の修正が行われる場合もある．

[*8] アーキテクチャベースラインは，それが使い捨てでないという点がプロトタイプとは異なる．統一プロセスの次フェーズでベースラインはより詳細化されていく．

統一プロセスの構築（construction）フェーズは，一般的なソフトウェアプロセスの構築アクティビティと名称を含めて全く同一である．構築フェーズでは，アーキテクチャモデルを入力として，各ユースケースを実現するソフトウェアコンポーネントを開発，もしくは入手する．そのためには，推敲フェーズから作成を始めた分析モデル，設計モデルは開発するインクリメントに対する最終版として完成している必要がある．ソフトウェアのインクリメント（すなわちリリース）に必要なすべてのフィーチャおよび機能は，ソースコードに実装される．コンポーネントが実装されるにつれて，ユニットテスト[*9]がテスト設計され実装される．その後，統合作業（コンポーネント結合とインテグレーションテスト）が実行される．受入テストがユースケースをもとに作成され，統一プロセスの次フェーズの開始前に受入テストが実施される．

[*9] （ユニットテストを含む）ソフトウェアテストの包括的な内容は第22章～第26章章にて記す．

統一プロセスの移行（transition）フェーズは，構築アクティビティの後半と，デプロイアクティビティの最初の部分（リリースとフィードバック）から構成される．ソフトウェアがエンドユーザにベータテストとして提供され，ユーザは欠陥と修正が必要な点について報告を行う．また，ソフトウェアチームは，ユーザマニュアル，トラブルシューティングガイド，およびインストール手順といったリリースに必要なサポート情報を作成する．移行フェーズの完了時には，ソフトウェアのインクリメントが利用可能なソフトウェアと扱われリリースされる．

統一プロセスの運用（production）フェーズは，一般的なプロセスのデプロイアクティビティと一致する．このフェーズでは，利用中のソフトウェアがモニタされ，稼動環境に対するサポートが行われ，欠陥レポートや変更要求が提示され，評価される．

構築，移行，運用の各フェーズが同時に実施されることや，次のインクリメントの開発が並行して始まっている場合もある．統一プロセスの5つのフェーズは順番に行われるのではなく，どちらかといえば，時間的に少しずらして並行実施されることを意味する．

ソフトウェアエンジニアリングのワークフローは，統一プロセスのすべてのフェーズにわたっている．チームは，必要に応じてプロセス（アクション，タスク，サブタスク，成果物）をカスタマイズすべきである．


## 2.6 プロダクトとプロセス

★新文書有、以下は省略多い★

プロセスが貧弱ならば，できあがった製品が思わしくないのは当然である．しかし，プロセスに過剰な信頼を寄せることも同じように危険である．★Margaret Davis★は，プロダクトとプロセスの双対性について次のように述べている@<bib>{Dav95a}．

>およそ5年から10年ごとに，ソフトウェアの分野では，プロダクトの問題からプロセスの問題に論点を移すことによって『問題』を再定義している．この結果，構造化プログラミング言語（プロダクト）を歓迎した後，構造化分析手法（プロセス）が続き，データのカプセル化（プロダクト）を歓迎した後，カーネギーメロン大学のSEIによるソフトウェア開発能力成熟度モデル（プロセス）がもてはやされている（オブジェクト指向手法が続き，アジャイルソフトウェア開発がさらに続く）．

>振り子は，自然な性質として両極端の地点の中間に落ち着くが，ソフトウェア分野では，片方のアプローチがうまくいかない場合には，新しい力が作用し，振り子が反対方向へ振れてしまうことが絶えず発生する．こうした振れがよくないのは，作業が適切に実行されていないことはいうまでもなく，仕事の意味が極端に変化するために開発者が混乱するからである．振れによって『問題』が解決されることはなく，失敗する運命にある．なぜなら，プロダクトとプロセスは双対的に捉えるものであるにもかかわらず，対立するものとして捉えているためである．

>相反する理論のどちらかだけでは，観察した矛盾を完全に説明することができない双対性という概念に対しては，自然科学の分野が先行している．粒子であり波でもあるという光の双対性は，★Louis de Broglie★が1920年代に提唱したときから受け入れられている．ソフトウェアという人工物そのものと，人工物を開発する作業を観察することによって，プロダクトとプロセスの間には根本的に双対性があると証明されることを私は確信している．完全な人工物をプロセスだけ，またはプロダクトだけしか見ないのであれば，その背景，使い方，意味，価値について決してわかりはしない．

>人間のすべての活動はプロセスとみなすことができるが，人間は誰でもそれらの活動から自分にとって価値のある意味を導き出している．そして，それを複数の人間によって使われたり価値を認められたり，繰り返し使われていくうちに，考慮されていなかった状況で使われる可能性がある表現や実例が生み出される．つまり人間は，自分自身や他の人間によるプロダクトの再利用から満足という感情を得るのである．

>したがって，ソフトウェア開発における再利用というゴールの迅速な浸透は，開発者が自分の仕事から得る満足を潜在的に増加させる一方で，プロダクトとプロセスの双対性の受け入れを急がせてもいる．再利用可能な人工物をプロダクトだけ，またはプロセスだけで考えると，相互の関係とその使い方があいまいになるか，人工物を使うたびにプロダクトが生み出され，プロダクトが他のソフトウェア開発活動のインプットとして使われるという事実を覆い隠してしまう．どちらかの見方を優先すると，再利用の機会が大幅に減少し，それにともなって仕事の満足度が上昇する機会も失われる．

人間は，プロダクトをつくり上げた達成感に劣らぬ満足感を，創造的なプロセスを行うことによっても得ることができる．芸術家は，額縁に納まる作品の仕上がりを楽しむように筆の運びそのものも楽しむ．作家は，書き上げた本と同じようによい隠喩を探すことを楽しむ．創造的なソフトウェアの開発者も，できあがったプロダクトと同じようにプロセスからも満足を得るべきである．ソフトウェアエンジニアリングに従事する創造的な人々が成長し続けるためには，プロダクトとプロセスの双対性が重要である．


## 2.7 まとめ

一般的なソフトウェアエンジニアリング向けのプロセスモデルは，フレームワーク，包括的なアクティビティ，アクション，タスクを包含したものである．プロセスフローによって，各プロセスモデル内のフレームワークアクティビティ，アクション，タスクが順序および時間に応じてどのように体系化されるかを表現することができる．プロセスパターンは，ソフトウェアプロセスにおいて遭遇する共通的な問題を解決するために使われる．

規範的なソフトウェアプロセスモデルは，ソフトウェア開発に秩序と構造をもたらすことを目的として長年適用されてきた．これらの従来型のモデルが提案するプロセスフローは少しずつ異なっているが，同一のフレームワークアクティビティ（コミュニケーション，計画策定，モデリング，構築，デプロイ）を実施している．

ウォーターフォールモデルやVモデルのような逐次的なプロセスモデルはもっとも古いソフトウェアエンジニアリングのパラダイムである．リニアプロセスフローと呼ばれるこれらのフローは，継続的な変更要求，進化するシステム，厳しいスケジュールなどのソフトウェア開発における現実とは適合しない場合がある．それでも，要求がきちんと定義されて変更される可能性が少ない状況においては，これらのプロセスフローは適用できる．

インクリメンタルプロセスモデルは，反復的なモデルであり，開発するソフトウェアのバージョンを高速に生み出す．進化型プロセスモデルは，ソフトウェア開発プロジェクトの多くが反復的でインクリメンタルな性質をもつという認識から，変化に対応することを目的として設計された．プロトタイピングやスパイラルモデルのような進化型モデルは，少量の追加成果物（あるいは，実行可能なソフトウェア）を迅速に作成する．これらのモデルは，コンセプト開発から長期にわたるシステム保守まであらゆるタイプのソフトウェア開発アクティビティに適用可能である．

統一プロセスは，「ユースケース駆動，アーキテクチャ中心，反復型およびインクリメンタル」なソフトウェアプロセスであり，UML手法およびツールを活用するためのフレームワークである．パーソナルソフトウェアプロセスならびにチームソフトウェアプロセスモデルはソフトウェアプロセスを成功裏に導くための重要要素として測定，計画策定，自発性を重視している．


## 問題と考察のポイント

2.1 本章の導入において★Baetjer★が「プロセスのなかで，ユーザと設計者，ユーザと開発ツール，設計者と開発ツールの間に関係が生まれる」と述べている．1. 設計者がユーザに尋ねるべき質問2. ユーザが設計者に尋ねるべき質問3. ユーザが開発するソフトウェア製品について自問すること4. 設計者が開発する製品とそのプロセスについて自問すること1～4それぞれについて5つの具体的な質問を挙げよ．

2.2 2.1節に示す各プロセスフローの違いを議論せよ．プロセスフローのいずれかを適用する際に起こりうる問題を特定せよ．

2.3 「コミュニケーション」のアクティビティにおける一連のアクションを示せ．提示したアクションの1つに対してタスクセットを作成せよ．

2.4 「コミュニケーション」における共通的な問題は，ソフトウェアがすべきことに対して2名のステークホルダがそれぞれ対立したアイデアをもつ場合に発生する．つまり，相互に対立した要求を持っているのである．2.4節にて示すテンプレートを用い，この問題を表現し効果的な解決アプローチを提案する（ステージパターンとなる）プロセスパターンを構築せよ．

2.5. ウォーターフォールモデルが適用可能だと考えられるソフトウェアプロジェクトの例を3つ挙げよ．具体的に示すこと．

2.6. プロトタイピングモデルが適用可能だと考えられるソフトウェアプロジェクトの例を3つ挙げよ．具体的に示すこと．

2.7. スパイラルプロセスのフローに従い，スパイラルの外側へと向かう際に，開発あるいは保守対象のソフトウェアはどのような状況であるか述べよ．

2.8. プロセスモデルを組合せることは可能か．モデル組合せが可能である場合には例を示せ．

2.9. ソフトウェアを「必要十分な」（good enough）品質で開発することの利点，欠点は何か．すなわち，開発スピードを品質よりも優先させる場合，どのようなことが起きるか．

2.10. ソフトウェアコンポーネント，あるいはプログラム全体でさえも，それが正しいことを証明することができる．では，なぜ皆がそれを行わないのだろうか．

2.11. 統一プロセスとUMLは同じものか．その回答について説明せよ．
